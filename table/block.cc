// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file. See the AUTHORS file for names of contributors.
//
// Decodes the blocks generated by block_builder.cc.

#include "table/block.h"

#include <algorithm>
#include <cstdint>
#include <vector>

#include "leveldb/comparator.h"
#include "table/format.h"
#include "util/coding.h"
#include "util/logging.h"

namespace leveldb {

/***
 * 计算 Block 中有多少个重启点
 * @return
 */
inline uint32_t Block::NumRestarts() const {
  assert(size_ >= sizeof(uint32_t));
  return DecodeFixed32(data_ + size_ - sizeof(uint32_t));
}

Block::Block(const BlockContents& contents)
    : data_(contents.data.data()),
      size_(contents.data.size()),
      owned_(contents.heap_allocated) {

  if (size_ < sizeof(uint32_t)) {
    size_ = 0;  // Error marker
  } else {
    // 模糊计算最多有多少个重启点
    size_t max_restarts_allowed = (size_ - sizeof(uint32_t)) / sizeof(uint32_t);

    if (NumRestarts() > max_restarts_allowed) {
      // The size is too small for NumRestarts()
      size_ = 0;
    } else {
      restart_offset_ = size_ - (1 + NumRestarts()) * sizeof(uint32_t);
    }
  }
}

Block::~Block() {
  if (owned_) {
    delete[] data_;
  }
}

/****
 *
 * 解码从 p 开始的下一个 entry，获取 shared_length, non_shared_length, value_length
 *
 * @param p             计算初始点
 * @param limit         限制位
 * @param shared        存储 share_key_length
 * @param non_shared    存储 non_share_key_length
 * @param value_length  存储 value_length
 *
 * @return  指向 delay_key 的指针
 */
static inline const char* DecodeEntry(const char* p, const char* limit,
                                      uint32_t* shared, uint32_t* non_shared, uint32_t* value_length) {
  if (limit - p < 3) return nullptr;

  *shared = reinterpret_cast<const uint8_t*>(p)[0];
  *non_shared = reinterpret_cast<const uint8_t*>(p)[1];
  *value_length = reinterpret_cast<const uint8_t*>(p)[2];

  if ((*shared | *non_shared | *value_length) < 128) {  // 表示如果只占一个字节
    // Fast path: all three values are encoded in one byte each
    p += 3;
  } else {
    // 填充计算
    if ((p = GetVarint32Ptr(p, limit, shared)) == nullptr) return nullptr;
    if ((p = GetVarint32Ptr(p, limit, non_shared)) == nullptr) return nullptr;
    if ((p = GetVarint32Ptr(p, limit, value_length)) == nullptr) return nullptr;
  }

  // 校验数据格式
  if (static_cast<uint32_t>(limit - p) < (*non_shared + *value_length)) {
    return nullptr;
  }

  // p 指向
  return p;
}

/***
 * Block 遍历器
 */
class Block::Iter : public Iterator {
 private:
  const Comparator* const comparator_;     // 比较器
  const char* const data_;                 // 数据体
  uint32_t const restarts_;                // 重启点距离数据的偏移量
  uint32_t const num_restarts_;            // 重启点的数量

  uint32_t current_;                       // 当前读取 entry 的偏移位置
  uint32_t restart_index_;                 // 当前 current_ 的左侧最近的重启点， 用来二分查找的缓存加速
  std::string key_;                        // block_build 的有效 key 数据
  Slice value_;                            // block_build 的有效 value 数据
  Status status_;                          // 读取状态

  /***
   * key 比较器
   */
  inline int Compare(const Slice& a, const Slice& b) const {
    return comparator_->Compare(a, b);
  }


  /***
   * 计算下一个 entry 距离 data_ 的偏移位置
   */
  inline uint32_t NextEntryOffset() const {
    return (value_.data() + value_.size()) - data_;
  }

  /***
   * 基于 index 获取对应的
   * @return restarts_[index]
   */
  uint32_t GetRestartPoint(uint32_t index) {
    assert(index < num_restarts_);
    return DecodeFixed32(data_ + restarts_ + index * sizeof(uint32_t));
  }

  /***
   * 设置 restart_index_ 并且为数据读取做准备
   */
  void SeekToRestartPoint(uint32_t index) {
    key_.clear();
    restart_index_ = index;       // 将 restart_index 定位到 index
    // current_ will be fixed by ParseNextKey();

    // ParseNextKey() starts at the end of value_, so set value_ accordingly
    uint32_t offset = GetRestartPoint(index);
    value_ = Slice(data_ + offset, 0);
  }

 public:
  Iter(const Comparator* comparator, const char* data, uint32_t restarts, uint32_t num_restarts)
      : comparator_(comparator),
        data_(data),
        restarts_(restarts),
        num_restarts_(num_restarts),
        current_(restarts_),
        restart_index_(num_restarts_) {
    assert(num_restarts_ > 0);
  }

  /***
   * 当前数据是否有效
   */
  bool Valid() const override { return current_ < restarts_; }

  Status status() const override { return status_; }

  Slice key() const override {
    assert(Valid());
    return key_;
  }

  Slice value() const override {
    assert(Valid());
    return value_;
  }

  /***
   * 从 block 中获取下一个 key_value
   */
  void Next() override {
    assert(Valid());
    ParseNextKey();
  }

  /***
   * 从 block 中读取上一个 key_value
   */
  void Prev() override {
    assert(Valid());

    // Scan backwards to a restart point before current_
    const uint32_t original = current_;
    // 定位到上一个重启点
    while (GetRestartPoint(restart_index_) >= original) {
      if (restart_index_ == 0) {
        // 表示此时 iter 停留在 block 第一个 key_value 中
        current_ = restarts_;
        restart_index_ = num_restarts_;
        return;
      }
      restart_index_--;
    }


    SeekToRestartPoint(restart_index_);
    do {
      // Loop until end of current entry hits the start of original entry
    } while (ParseNextKey() && NextEntryOffset() < original);
  }

  /***
   * 使用二分查找法， 遍历 block 试图找到对应的 key
   */
  void Seek(const Slice& target) override {
    // Binary search in restart array to find the last restart point
    // with a key < target
    uint32_t left = 0;                      // 偏移点下限
    uint32_t right = num_restarts_ - 1;     // 偏移点上限

    int current_key_compare = 0;

    if (Valid()) {
      // 表示存在有效数据， 利用上次查询加速这次数据查询过程
      current_key_compare = Compare(key_, target);
      if (current_key_compare < 0) {
        left = restart_index_;
      } else if (current_key_compare > 0) {
        right = restart_index_;
      } else {
        return;
      }
    }

     // 使用二分查找
     //
     // 每次只跟每个重启块 的 第一个Key进行比较
     // 因为第一个key是完整的， 所以比较速度快
    while (left < right) {
      uint32_t mid = (left + right + 1) / 2;

      uint32_t region_offset = GetRestartPoint(mid);
      uint32_t shared, non_shared, value_length;

      // 获取 data[mid] 的 block 的首 key
      const char* key_ptr = DecodeEntry(data_ + region_offset, data_ + restarts_, &shared, &non_shared, &value_length);

      if (key_ptr == nullptr || (shared != 0)) {
        CorruptionError();
        return;
      }

      Slice mid_key(key_ptr, non_shared);

      if (Compare(mid_key, target) < 0) {
        // 数据在右边
        left = mid;
      } else {
        // 数据在左边
        right = mid - 1;
      }
    }

    // left == right == mid || Compare(mid_key) == 0

    // We might be able to use our current position within the restart block.
    // This is true if we determined the key we desire is in the current block and is after than the current key.
    assert(current_key_compare == 0 || Valid());
    bool skip_seek = left == restart_index_ && current_key_compare < 0;  // false

    if (!skip_seek) {
      SeekToRestartPoint(left);
    }
    // Linear search (within restart block) for first key >= target
    while (true) {
      if (!ParseNextKey()) {
        return;
      }
      // 可以 从小到达排序
      if (Compare(key_, target) >= 0) {
        return;
      }
    }
  }

  /***
   * 获取 block 第一个 entry 的 key_value
   */
  void SeekToFirst() override {
    SeekToRestartPoint(0);
    ParseNextKey();
  }

  /***
   * 获取 block 的最后一个entry的最后一个 key_value
   */
  void SeekToLast() override {
    SeekToRestartPoint(num_restarts_ - 1);
    while (ParseNextKey() && NextEntryOffset() < restarts_) {
      // Keep skipping
    }
  }

 private:
  void CorruptionError() {
    current_ = restarts_;
    restart_index_ = num_restarts_;
    status_ = Status::Corruption("bad entry in block");
    key_.clear();
    value_.clear();
  }

  /***
   * 从当前 value_ 位置移动到下一个有效的 entry
   * 并且计算处下一步的 key_vaue
   */
  bool ParseNextKey() {

    current_ = NextEntryOffset();  // 当前要读取数据偏移位置

    const char* p = data_ + current_;
    const char* limit = data_ + restarts_;  // 有效数据体的上限位置

    if (p >= limit) {  // 没有有效数据
      // 设置当前状态为无效
      current_ = restarts_;
      restart_index_ = num_restarts_;
      return false;
    }

    // Decode next entry
    uint32_t shared, non_shared, value_length;

    p = DecodeEntry(p, limit, &shared, &non_shared, &value_length);
    if (p == nullptr || key_.size() < shared) {
      CorruptionError();
      return false;
    } else {
      key_.resize(shared);
      key_.append(p, non_shared);
      value_ = Slice(p + non_shared, value_length);

      // 将 restart_index 设置为 小于 current_ 偏移的最近的重启点
      while (restart_index_ + 1 < num_restarts_ && GetRestartPoint(restart_index_ + 1) < current_) {
        ++restart_index_;
      }
      return true;
    }
  }
};

Iterator* Block::NewIterator(const Comparator* comparator) {
  if (size_ < sizeof(uint32_t)) {
    return NewErrorIterator(Status::Corruption("bad block contents"));
  }
  const uint32_t num_restarts = NumRestarts();

  if (num_restarts == 0) {
    return NewEmptyIterator();
  } else {
    return new Iter(comparator, data_, restart_offset_, num_restarts);
  }
}

}  // namespace leveldb
